<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffer geometry custom attributes - particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			a {
				color: #fff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - buffergeometry custom attributes - particles</div>

		<script src="js/three.js"></script>
		<script src="js/jQuery.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/math/Lut.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;
			attribute float alpha;

		    	varying float vAlpha;
			varying vec3 vColor;

			void main() {

				vColor = customColor;
				
				vAlpha = alpha;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 300.0 / -mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;
			varying float vAlpha;

			void main() {

				gl_FragColor = vec4( color * vColor, vAlpha );

				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>


		<script>

		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		var renderer, scene, camera, stats;
		var System;
	
		var colorMap;
		var numberOfColors;
		var lut;
	
		var options, gui;

		var moleculeFolder, viewFolder, sliderFolder, pointCloudFolder, boxFolder, pointMatrixFolder;

		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		
		var n_test;
		var target_test;
		
		options = new function(){
				this.pointCloudParticles = 100;
				this.pointCloudColorSetting = 1.2;
				this.pointCloudAlpha = 1;
				this.pointCloudSize = 1;
				this.boxParticles = 200;
				this.boxColorSetting = 10.0;
				this.boxSize = 10;
				this.boxOpacity = 1;
				this.pointMatrixParticles = 100;
				this.pointMatrixColorSetting = 1.2;
				this.pointMatrixAlpha = 1;
				this.pointMatrixSize = 10;
				this.x_low = 0;
				this.x_high = 100;
				this.y_low = 0;
				this.y_high = 100;
				this.z_low = 0;
				this.z_high = 100;
				this.view = 'pointCloud';
				this.moleculeName = 'CO2';
				this.propertyOfInterest = 'n';
				this.colorMap = 'rainbow';
				this.densityFilename = "data/CO2_B3LYP_0_0_0_n.json";
				this.targetFilename = "data/CO2_B3LYP_0_0_0_n.json";
			};
		
		
		$.getJSON("data/CO2_B3LYP_0_0_0_n.json", function(json1) {
			n_test = json1; // this will show the info it in firebug console
			$.getJSON("data/CO2_B3LYP_0_0_0_n.json", function(json2) {
				target_test = json2;
				init();
				animate();
			});		
		});
		

		function init() {

			camera = new THREE.PerspectiveCamera( 100, WIDTH / HEIGHT, 1, 10000 );
			camera.position.z = 800;

			scene = new THREE.Scene();

			System = getPointCloudGeometry(options)
			scene.add( System );

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( WIDTH, HEIGHT );
			controls = new THREE.OrbitControls( camera, renderer.domElement );

			var container = document.getElementById( 'container' );
			container.appendChild( renderer.domElement );

			stats = new Stats();
			container.appendChild( stats.dom );

			
			gui = new dat.GUI();
			setControlPanel(options);
			

			window.addEventListener( 'resize', onWindowResize, false );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			requestAnimationFrame( animate );

			render();
			stats.update();

		}

		function render() {

			renderer.render( scene, camera );

		}

		function updateControlPanel(options){
			if (options.view == 'pointCloud'){
				pointCloudFolder.open();
				boxFolder.close();
				pointMatrixFolder.close();

			}
			else if (options.view == 'box'){
				pointCloudFolder.close()
				boxFolder.open();
				pointMatrixFolder.close();
			}
			else if (options.view == 'pointMatrix'){
				pointCloudFolder.close()
				boxFolder.close();
				pointMatrixFolder.open();
			}
		}

		function setControlPanel(options){
			moleculeFolder 		= gui.addFolder( 'Molecule Selection' );
			viewFolder 		= gui.addFolder( 'View Selection' );
			pointCloudFolder 	= gui.addFolder( 'point cloud control' );
			boxFolder 		= gui.addFolder( 'box control' );
			pointMatrixFolder 	= gui.addFolder( 'point matrix control' );
			sliderFolder 		= gui.addFolder( 'Slider Control' );
			
			moleculeFolder.add( options, 'moleculeName',{'CO2':'CO2', 'H2O':'H2O', 'CO':'CO', 'CH4':'CH4'}).onChange( function( value ) {
				updateOptionFilenames();
				$.getJSON(options.densityFilename, function(json1) {
					n_test = json; // this will show the info it in firebug console
					$.getJSON(options.targetFilename, function(json2) {
						target_test = json2;
						updateGeometry(options);
					});
				});	
			});				
			moleculeFolder.add( options, 'propertyOfInterest',{'n':'n','e':'e', 'x':'x', 'y':'y', 'z':'z'}).onChange( function( value ) {
				updateOptionFilenames();
				console.log(options.densityFilename,options.targetFilename)
				$.getJSON(options.targetFilename, function(json2) {
					target_test = json2;
					updateGeometry(options);
				});	
			});
			moleculeFolder.open();
			
			
			
			viewFolder.add( options, 'view',{'pointCloud':'pointCloud', 'box':'box', 'pointMatrix':'pointMatrix'}).onChange( function( value ){
				updateGeometry(options);
				updateControlPanel(options);
			});
			viewFolder.add( options, 'colorMap',{'rainbow':'rainbow', 'cooltowarm':'cooltowarm', 'blackbody':'blackbody', 'grayscale':'grayscale'}).onChange( function( value ){
				updateGeometry(options);			
			});
			viewFolder.open();
			
			
			
			pointCloudFolder.add( options, 'pointCloudParticles', 10, 5000 ).step( 10 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointCloudFolder.add( options, 'pointCloudAlpha',     0, 1 ).step( 0.01 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointCloudFolder.add( options, 'pointCloudSize', 0, 10 ).step( 0.1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointCloudFolder.add( options, 'pointCloudColorSetting', 0.1, 20.0 ).step( 0.1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointCloudFolder.open();


			boxFolder.add( options, 'boxParticles', 10, 1000 ).step( 10 ).onChange( function( value ) {
				updateGeometry(options);
			});
			boxFolder.add( options, 'boxSize', 0, 10 ).step( 0.1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			boxFolder.add( options, 'boxColorSetting', 0.1, 20.0 ).step( 0.1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			boxFolder.add( options, 'boxOpacity', 0.01, 1 ).step( 0.01 ).onChange( function( value ) {
				updateGeometry(options);
			});


			pointMatrixFolder.add( options, 'pointMatrixParticles', 10, 5000 ).step( 10 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointMatrixFolder.add( options, 'pointMatrixAlpha',     0, 1 ).step( 0.01 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointMatrixFolder.add( options, 'pointMatrixSize', 0, 10 ).step( 0.1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			pointMatrixFolder.add( options, 'pointMatrixColorSetting', 0.1, 20.0 ).step( 0.1 ).onChange( function( value ) {
				updateGeometry(options);
			});



			sliderFolder.add( options, 'x_low', 0, 100 ).step( 1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			sliderFolder.add( options, 'x_high', 0, 100 ).step( 1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			sliderFolder.add( options, 'y_low', 0, 100  ).step( 1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			sliderFolder.add( options, 'y_high', 0, 100  ).step( 1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			sliderFolder.add( options, 'z_low', 0, 100  ).step( 1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			sliderFolder.add( options, 'z_high', 0, 100  ).step( 1 ).onChange( function( value ) {
				updateGeometry(options);
			});
			sliderFolder.open();
		}


		function updateGeometry(options){
			scene.remove(System);
			System = getGeometry(options);
			scene.add( System );
		}

		function getGeometry(options){
			var temp;
			if (options.view == 'pointCloud'){
				temp = getPointCloudGeometry(options);
			}
			else if (options.view == 'box'){
				temp = getBoxGeometry(options);
			}
			else if (options.view == 'pointMatrix'){
				temp = getPointMatrixGeometry(options);
			}
			else {
				temp = getPointCloudGeometry(options);
			}

			return temp
		}
		
		function updateOptionFilenames() {
			options.densityFilename = "data/" + options.moleculeName + "_B3LYP_0_0_0_n.json";
			options.targetFilename = "data/" + options.moleculeName + "_B3LYP_0_0_0_" + options.propertyOfInterest +".json";
			console.log(options.densityFilename, options.targetFilename);
		}
		
		
		function getPointCloudGeometry(options){
			var uniforms = {

				color:     { value: new THREE.Color( 0xffffff ) },
				texture:   { value: new THREE.TextureLoader().load( "textures/sprites/disc.png" ) }

			};

			var shaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       uniforms,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});
			var particles = options.pointCloudParticles;
			var num_blocks = 1000000;
			var points_in_block = new Float32Array(num_blocks);
			var total = 100;
			var count = 0;
		
			for ( var k = 0; k < num_blocks; k ++) {
				var num_points  = Math.floor((n_test[k] / total) * particles);
				points_in_block[k] = num_points;
				count += num_points;
			}
			
			var n = 100;
			var n2 = Math.pow(n,2);
			var n_inc = n/2;

			geometry = new THREE.BufferGeometry();

			var positions = new Float32Array(count*3);
			var colors = new Float32Array(count *3);
			var sizes = new Float32Array( count);
			var alphas = new Float32Array( count);
			
			colorMap = options.colorMap;
			numberOfColors = 512;
			
			lut = new THREE.Lut( colorMap, numberOfColors );
			lut.setMax( options.pointCloudColorSetting);
			lut.setMin( 0 );
			
			var i = 0, i3 = 0;
			var temp_num_points = 0;
			for ( var k = 0; k < num_blocks; k ++) {
				temp_num_points  =  points_in_block[k];
				if (temp_num_points > 0){
					var x_start = k%n;
					var y_start = ((k-(k%n))/n)%n;
					var z_start = (k-(k%n2))/n2;
					var x_end = x_start + 1;
					var y_end = y_start + 1;
					var z_end = z_start + 1;
					
					for (var j = 0; j < temp_num_points; j ++){

						var x = Math.random()  + x_start;
						var y = Math.random()  + y_start;
						var z = Math.random()  + z_start;
						
						positions[ i3 + 0 ] = (x - n_inc)*10;
						positions[ i3 + 1 ] = (y - n_inc)*10;
						positions[ i3 + 2 ] = (z - n_inc)*10;
						var color = lut.getColor( target_test[k] );
						
						colors[ i3 + 0 ] = color.r;
						colors[ i3 + 1 ] = color.g;
						colors[ i3 + 2 ] = color.b;
						
						if (	(x_start >= options.x_low) 	&& (x_end <= options.x_high) 	&&
							(y_start >= options.y_low) 	&& (y_end <= options.y_high)	&&
							(z_start >= options.z_low) 	&& (z_end <= options.z_high)	)
							{
								alphas[ i ] = options.pointCloudAlpha;
								sizes[ i ] = options.pointCloudSize;
							}
						else {
							alphas[ i ] = 0;
							sizes[ i ] = 0;
						}

						
						i++;
						i3+=3;
					}
				}			
			}
				
			

			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
			geometry.addAttribute( 'alpha', new THREE.BufferAttribute( alphas, 1 ) );

			var System = new THREE.Points( geometry, shaderMaterial );
			
			return System;
		
		}

		
		function getBoxGeometry(options){
			console.log('re-calculating geometry');

			var material = new THREE.MeshBasicMaterial( {
				color: 0xffffff, 
				vertexColors: THREE.FaceColors,
				opacity: options.boxOpacity,
				transparent: true
				 } );
			var mergedGeometry = new THREE.Geometry();

			var particles = options.boxParticles;
			var num_blocks = 1000000;
			var points_in_block = new Float32Array(num_blocks);
			var total = 100;
			var count = 0;


		
			for ( var k = 0; k < num_blocks; k ++) {
				var num_points  = Math.floor((n_test[k] / total) * particles);
				points_in_block[k] = num_points;
				count += 1;
			}
			var colors = new Array(count);
			
			var n = 100;
			var n2 = Math.pow(n,2);
			var n_inc = n/2;
			
			colorMap = options.colorMap;
			numberOfColors = 512;
			
			lut = new THREE.Lut( colorMap, numberOfColors );
			lut.setMax( options.boxColorSetting);
			lut.setMin( 0 );

			var i = 0;
			for ( var k = 0; k < num_blocks; k ++) {
				if (points_in_block[k] > 0){
					var x_start = k%n;
					var y_start = ((k-(k%n))/n)%n;
					var z_start = (k-(k%n2))/n2;
					var x_end = x_start + 1;
					var y_end = y_start + 1;
					var z_end = z_start + 1;
					
					if (	(x_start >= options.x_low) 	&& (x_end <= options.x_high) 	&&
						(y_start >= options.y_low) 	&& (y_end <= options.y_high)	&&
						(z_start >= options.z_low) 	&& (z_end <= options.z_high)	){

						var tempColor = lut.getColor( target_test[k] );
						var tempGeometry = new THREE.BoxGeometry( options.boxSize, options.boxSize, options.boxSize );

						tempGeometry.translate( (x_start - n_inc)*10 , (y_start - n_inc)*10 ,(z_start - n_inc)*10 );
						mergedGeometry.merge(tempGeometry);
						
						for (var q = 0; q < 12; q ++){
							//colors.push(tempColor.getHex ());
							colors[i] = tempColor.getHex ();
							i++;
						}
					}			
				}			
			}
			
			for ( var i = 0; i < mergedGeometry.faces.length; i ++ ) {

			    var face = mergedGeometry.faces[ i ];
			    face.color.setHex( colors[i]);

			}
			
			var mesh = new THREE.Mesh( mergedGeometry, material );

			console.log(' end re-calculating geometry');
			return mesh;
	
		}

		function getPointMatrixGeometry(options) {
			var uniforms = {

				color:     { value: new THREE.Color( 0xffffff ) },
				texture:   { value: new THREE.TextureLoader().load( "textures/sprites/disc.png" ) }

			};

			var shaderMaterial = new THREE.ShaderMaterial( {

				uniforms:       uniforms,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true

			});
			var particles = options.pointMatrixParticles;

			var geometry = new THREE.BufferGeometry();

			var num_blocks = 1000000;
			var points_in_block = new Float32Array(num_blocks);
			var total = 100;
			var count = 0;
			for ( var k = 0; k < num_blocks; k ++) {
				var num_points  = Math.floor((n_test[k] / total) * particles);
				points_in_block[k] = num_points;
				count += 1;
			}
			var positions = new Float32Array(count*3);
			var colors = new Float32Array(count *3);
			var sizes = new Float32Array( count);
			var alphas = new Float32Array( count);
			
			var n = 100;
			var n2 = Math.pow(n,2);
			var n_inc = n/2;
			
			colorMap = options.colorMap;
			numberOfColors = 512;
			
			lut = new THREE.Lut( colorMap, numberOfColors );
			lut.setMax( options.boxColorSetting);
			lut.setMin( 0 );

			var i = 0;
			var i3 = 0;
			for ( var k = 0; k < num_blocks; k ++) {
				if (points_in_block[k] > 0){
					var x_start = k%n;
					var y_start = ((k-(k%n))/n)%n;
					var z_start = (k-(k%n2))/n2;
					var x_end = x_start + 1;
					var y_end = y_start + 1;
					var z_end = z_start + 1;

					var color = lut.getColor( target_test[k] );

					positions[ i3 ]     = (x_start - n_inc)*10;
					positions[ i3 + 1 ] = (y_start - n_inc)*10;
					positions[ i3 + 2 ] = (z_start - n_inc)*10;

					colors[ i3 ]     = color.r;
					colors[ i3 + 1 ] = color.g;
					colors[ i3 + 2 ] = color.b;

					if (	(x_start >= options.x_low) 	&& (x_end <= options.x_high) 	&&
						(y_start >= options.y_low) 	&& (y_end <= options.y_high)	&&
						(z_start >= options.z_low) 	&& (z_end <= options.z_high)	)
						{
							alphas[ i ] = options.pointMatrixAlpha;
							sizes[ i ] = Math.min(5,n_test[k] * options.pointMatrixSize);
						}
					else {
						alphas[ i ] = 0;
						sizes[ i ] = 0;
					}
					i++;
					i3 += 3;			
				}			
			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
			geometry.addAttribute( 'alpha', new THREE.BufferAttribute( alphas, 1 ) );

			var System = new THREE.Points( geometry, shaderMaterial );
			
			return System;


		}
	</script>

</body>
</html>
